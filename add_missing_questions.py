import json

# 기존 데이터 로드
with open('quiz_data_complete.json', 'r', encoding='utf-8') as f:
    data = json.load(f)

# 누락된 문제 추가

# 112회 7번 (인덱스 6)
q112_7 = {
    "question": "다음의 자료를 이용하여 개별원가계산을 수행할 경우 2024년 기말의 미완성 작업에 해당하는 번호를 모두 고르시오.\n\n① 103번 ③ 105번\n② 104번 ④ 106번",
    "options": [
        "① ③",
        "② ④",
        "작업원가표 번호 101번 102번 103번 104번 105번 106번\n시작일 2023.10.19. 2023.12.21. 2024.10.01. 2024.10.05. 2024.11.03. 2024.12.01.\n완성일 2024.01.21. 2024.01.15. 진행 중 2024.12.28. 진행 중 진행 중",
        "③ ⑤ ⑥"
    ],
    "correct": 2,
    "explanation": "기말재공품(미완성작업)：작업원가표 103, 105, 106번"
}

# 114회 6번 (인덱스 5)
q114_6 = {
    "question": "다음 중 기본원가에 해당하면서 동시에 가공원가에 해당하는 것은?",
    "options": [
        "직접재료원가",
        "직접노무원가",
        "제조간접원가",
        "직접재료원가와 직접노무원가"
    ],
    "correct": 1,
    "explanation": "기본원가와 가공원가에 모두 포함되는 것은 직접노무원가이다.\nㆍ직접재료원가＋직접노무원가＝기본원가\nㆍ직접노무원가＋제조간접원가＝가공원가"
}

# 114회 7번 (인덱스 6) - 연산품원가계산 문제
q114_7 = {
    "question": "㈜미르는 동일한 원재료를 투입하여 동일한 제조공정에서 제품 A, B, C를 생산하고 있다. 세 가지 제품에 공통적으로 투입된 결합원가가 400,000원일 때, 순실현가치법으로 결합원가를 배부하는 경우 제품 B의 제조원가는 얼마인가?\n\n제품 생산량 단위당 판매가격 추가가공원가(총액)\nA 200㎏ @3,000원 없음\nB 250㎏ @2,000원 125,000원\nC 500㎏ @1,200원 75,000원",
    "options": [
        "100,000원",
        "165,000원",
        "200,000원",
        "225,000원"
    ],
    "correct": 3,
    "explanation": "※ 연산품원가계산은 전산세무2급 시험의 평가범위가 아니므로 모두 정답으로 인정합니다.\n④ 225,000원\n＝결합원가 배부액 100,000원+추가가공원가 125,000원\n구분 순실현가치 결합원가 배부액\nA 200㎏×@3,000원＝600,000원 160,000원\nB 250㎏×@2,000원－125,000원＝375,000원 100,000원\nC 500㎏×@1,200원－75,000원＝525,000원 140,000원\n합계 1,500,000원 400,000원"
}

# 114회 11번 (인덱스 10)
q114_11 = {
    "question": "다음 중 우리나라 부가가치세법의 특징에 대한 설명으로 옳지 않은 것은?",
    "options": [
        "전단계세액공제법",
        "간접세",
        "소비행위에 대하여 과세",
        "생산지국 과세원칙"
    ],
    "correct": 3,
    "explanation": "소비지국 과세원칙을 구현하기 위해 영세율 제도를 두고 있으며 재화의 수입에 대하여 내국물품과 동일하게 과세한다."
}

# 115회 12번 (인덱스 11)
q115_12 = {
    "question": "다음 중 부가가치세법상 재화의 공급시기에 대한 설명으로 틀린 것은?",
    "options": [
        "재화의 이동이 필요없는 경우에는 재화가 이용가능하게 되는 때이다.",
        "재화의 이동이 필요한 경우에는 재화의 이동이 시작되는 때이다.",
        "현금판매의 경우 대금을 청산하는 때이다.",
        "할부판매의 경우 재화가 인도되는 때이다."
    ],
    "correct": 1,
    "explanation": "재화의 이동이 필요한 경우에는 재화의 이동이 끝나는 때이다."
}

# 116회 1번 (인덱스 0)
q116_1 = {
    "question": "다음 중 자본적 지출 항목을 수익적 지출로 잘못 회계처리한 경우 재무제표에 미치는 영향으로 옳은 것은?",
    "options": [
        "자산이 과소계상 된다.",
        "당기순이익이 과대계상 된다.",
        "부채가 과소계상 된다.",
        "자본이 과대계상 된다."
    ],
    "correct": 0,
    "explanation": "자산을 비용으로 계상하면 자산과 당기순이익 및 자본이 과소계상 된다. 부채에는 영향이 없다."
}

# 117회 1번 (인덱스 0)
q117_1 = {
    "question": "다음 중 자산, 부채의 분류가 잘못 연결된 것은?",
    "options": [
        "임차보증금－비유동자산",
        "사채－유동부채",
        "퇴직급여충당부채－비유동부채",
        "선급비용－유동자산"
    ],
    "correct": 1,
    "explanation": "사채는 비유동부채이다."
}

# 117회 6번 (인덱스 5)
q117_6 = {
    "question": "다음 중 공손에 대한 설명으로 옳지 않은 것은?",
    "options": [
        "정상공손은 단기적으로 발생이 예측 가능하고 단기적으로 통제가능하다.",
        "비정상공손은 통제가능하며 당기에 영업외비용으로 처리한다.",
        "정상공손은 공손이 발견되는 점까지의 제품원가로 계산한다.",
        "비정상공손은 공손이 발견되는 점까지의 제품원가로 계산한다."
    ],
    "correct": 0,
    "explanation": "정상공손은 단기적으로 발생이 예측 가능하지만 단기적으로 통제불가능하다."
}

# 118회 6번 (인덱스 5)
q118_6 = {
    "question": "다음 중 아래의 그래프가 표시하는 원가행태로 가장 적절한 것은?\n\n[ 그래프(가) ] 총원가가 조업도에 따라 계단식으로 증가\n[ 그래프(나) ] 단위당 원가가 조업도에 따라 일정",
    "options": [
        "그래프(가)：변동원가",
        "그래프(나)：준고정원가",
        "그래프(가)：준고정원가",
        "그래프(나)：고정원가"
    ],
    "correct": 2,
    "explanation": "그래프(가)는 준고정원가, 그래프(나)는 변동원가를 표현하는 그래프이다."
}

# 데이터 삽입
data['quiz112'].insert(6, q112_7)  # 7번 위치에 삽입
data['quiz114'].insert(5, q114_6)  # 6번 위치에 삽입
data['quiz114'].insert(6, q114_7)  # 7번 위치에 삽입 (이미 6번이 추가되었으므로)
data['quiz114'].insert(10, q114_11)  # 11번 위치에 삽입
data['quiz115'].insert(11, q115_12)  # 12번 위치에 삽입
data['quiz116'].insert(0, q116_1)  # 1번 위치에 삽입 (맨 앞)
data['quiz117'].insert(0, q117_1)  # 1번 위치에 삽입 (맨 앞)
data['quiz117'].insert(5, q117_6)  # 6번 위치에 삽입
data['quiz118'].insert(5, q118_6)  # 6번 위치에 삽입

# 저장
with open('quiz_data_final_complete.json', 'w', encoding='utf-8') as f:
    json.dump(data, f, ensure_ascii=False, indent=2)

# 통계 출력
print("✅ 누락 문제 추가 완료!\n")
print("=" * 60)
for key in sorted(data.keys(), key=lambda x: int(x.replace('quiz', ''))):
    count = len(data[key])
    if count == 15:
        print(f"  ✅ {key}: {count}개")
    else:
        print(f"  ⚠️ {key}: {count}개")

print("=" * 60)
total = sum(len(data[k]) for k in data)
print(f"\n총 문제 수: {total}/165개 ({total/165*100:.1f}%)")

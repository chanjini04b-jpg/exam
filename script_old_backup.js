// 전산세무2급 기출문제 데이터
// quiz_all_data.js 파일에서 로드됨
// roundData 객체는 외부 파일에 정의되어 있습니다.

let currentQuestion = 0;
        ],
        correct: 3,
        explanation: "계정과목을 단기매매증권으로 분류변경하는 것이 아니라, 만기보유증권(유동자산)으로 분류변경한다."
    },
    {
        question: "다음의 회계상 거래가 2023년 재무제표에 미치는 영향으로 옳지 않은 것은?\n\n영업부의 업무용 차량에 대한 보험료(보험기간：2023.07.01.~2024.06.30.)를 2023년 7월 1일에 지급하고 전부 비용으로 회계처리하였다. 2023년 12월 31일 결산일 현재 별도의 회계처리를 하지 않았다.",
        options: [
            "자산 과대",
            "비용 과대",
            "당기순이익 과소",
            "부채 영향 없음"
        ],
        correct: 0,
        explanation: "미반영 회계처리：(차) 선급비용(자산) (대) 보험료(비용). 즉, 자산 과소, 비용 과대, 당기순이익 과소, 부채는 영향이 없다."
    },
    {
        question: "다음 중 유형자산의 취득 이후 지출에 대한 설명으로 가장 옳지 않은 것은?",
        options: [
            "유형자산의 인식기준을 충족하는 경우에는 자본적 지출로 처리하고, 충족하지 못한 경우에는 수익적 지출로 처리한다.",
            "본래의 용도를 변경하기 위한 지출은 자본적 지출에 해당한다.",
            "자산의 원상회복, 수선유지를 위한 지출 등은 자본적 지출에 해당한다.",
            "건물 벽의 도장, 파손된 유리창 대체, 일반적인 소액 수선비는 수익적 지출에 해당한다."
        ],
        correct: 2,
        explanation: "원상회복, 수선유지를 위한 지출은 수익적 지출에 해당한다."
    },
    {
        question: "다음 중 용역의 제공으로 인한 수익인식의 조건에 대한 설명으로 틀린 것은?",
        options: [
            "용역제공거래의 성과를 신뢰성 있게 추정할 수 있을 때 진행기준에 따라 인식한다.",
            "이미 발생한 원가와 그 거래를 완료하기 위해 추가로 발생할 것으로 추정되는 원가의 합계액이 총수익을 초과하는 경우에는 그 초과액과 이미 인식한 이익의 합계액을 전액 당기손실로 인식한다.",
            "용역제공거래의 성과를 신뢰성 있게 추정할 수 없는 경우에는 발생한 비용의 범위 내에서 회수가능한 금액을 수익으로 인식한다.",
            "용역제공거래의 성과를 신뢰성 있게 추정할 수 없고 발생한 원가의 회수가능성이 낮은 경우에는 수익을 인식하지 않고 발생한 원가도 비용으로 인식하지 않는다."
        ],
        correct: 3,
        explanation: "일반기업회계기준 문단 16.14: 용역제공거래의 성과를 신뢰성 있게 추정할 수 없고 발생한 원가의 회수가능성이 낮은 경우에도 발생한 원가는 비용으로 인식한다."
    },
    {
        question: "다음 중 일반기업회계기준상 보수주의에 대한 예시로 옳지 않은 것은?",
        options: [
            "재고자산의 평가 시 저가주의에 따른다.",
            "회계연도의 이익을 줄이기 위해 유형자산의 내용연수를 임의로 단축한다.",
            "물가 상승 시 재고자산평가방법으로 후입선출법을 적용한다.",
            "우발손실은 인식하나 우발이익은 인식하지 않는다."
        ],
        correct: 1,
        explanation: "회계연도의 이익을 줄이기 위해 유형자산의 내용연수를 임의로 단축하는 것은 회계처리의 오류이다."
    },
    {
        question: "다음 중 원가행태(조업도)에 따른 분류에 대한 설명으로 가장 틀린 것은?",
        options: [
            "고정원가는 조업도의 변동과 관계없이 일정하게 발생하는 원가이다.",
            "조업도가 증가하면 총 변동원가도 증가한다.",
            "제조공장의 임차료는 대표적인 고정원가이다.",
            "조업도가 감소하면 단위당 변동원가는 증가한다."
        ],
        correct: 3,
        explanation: "조업도가 증가하거나 감소하더라도 단위당 변동원가는 변함이 없다."
    },
    {
        question: "㈜한국은 제조간접원가를 직접노무시간 기준으로 배부하고 있으며 제조간접원가 배부율은 시간당 2,000원이다. 제조간접원가 실제 발생액이 18,000,000원이고, 실제 직접노무시간이 10,000시간이 발생한 경우 제조간접원가 배부차이는 얼마인가?",
        options: [
            "2,000,000원 과대배부",
            "2,000,000원 과소배부",
            "3,000,000원 과소배부",
            "배부차이 없음"
        ],
        correct: 0,
        explanation: "2,000,000원 과대배부 = 실제발생액 18,000,000원 - 예정배부액 20,000,000원. 예정배부액: 실제 직접노무시간 10,000시간 × 제조간접원가 배부율 2,000원 = 20,000,000원"
    },
    {
        question: "다음은 ㈜한국의 제조활동과 관련된 물량흐름 관련 자료이다. 이에 대한 설명으로 옳은 것은?\n\n• 기초재공품: 500개\n• 기말재공품: 300개\n• 당기착수량: 5,000개\n• 공손품수량: 700개",
        options: [
            "완성품의 10%가 정상공손이면 완성품수량은 4,200개이다.",
            "완성품의 10%가 정상공손이면 정상공손수량은 450개이다.",
            "완성품의 10%가 정상공손이면 비정상공손수량은 280개이다.",
            "완성품의 10%가 정상공손이면 정상공손수량은 420개이다."
        ],
        correct: 1,
        explanation: "완성품수량: 기초재공품 500개 + 당기착수 5,000개 - 기말재공품 300개 - 공손품 700개 = 4,500개. 정상공손수량: 당기완성품 4,500개 × 10% = 450개. 비정상공손수량: 공손품 700개 - 정상공손 450개 = 250개"
    },
    {
        question: "다음 중 개별원가계산에 대한 설명으로 옳지 않은 것은?",
        options: [
            "작업원가표를 근거로 원가계산을 한다.",
            "직접원가와 제조간접원가의 구분이 중요하다.",
            "공정별 제품원가 집계 후 해당 공정의 생산량으로 나누어 단위당 원가를 계산하는 방식이다.",
            "주문생산형태에 적합한 원가계산방식이다."
        ],
        correct: 2,
        explanation: "종합원가계산에 대한 설명이다."
    },
    {
        question: "아래의 자료를 이용하여 평균법에 의한 가공원가의 완성품환산량을 계산하면 얼마인가?\n\n구분 | 수량 | 완성도\n기초재공품 | 1,000개 | 50%\n당기착수 | 3,000개 |\n기말재공품 | 2,000개 | 40%",
        options: [
            "2,800개",
            "3,800개",
            "4,000개",
            "4,300개"
        ],
        correct: 0,
        explanation: "2,800개 = 완성품 2,000개 + 기말재공품 2,000개 × 40%"
    },
    {
        question: "다음 중 부가가치세법상 간이과세자에 대한 설명으로 가장 틀린 것은?",
        options: [
            "간이과세자란 원칙적으로 직전 연도의 공급대가의 합계액이 8,000만원에 미달하는 사업자를 말한다.",
            "직전 연도의 공급대가의 합계액이 4,800만원 이상인 부동산임대사업자는 간이과세자로 보지 않는다.",
            "간이과세자는 세금계산서를 발급받은 재화의 공급대가에 1%를 곱한 금액을 납부세액에서 공제한다.",
            "직전 연도의 공급대가의 합계액이 4,800만원 미만인 간이과세자는 세금계산서를 발급할 수 없다."
        ],
        correct: 2,
        explanation: "간이과세자는 세금계산서를 발급받은 재화의 공급대가에 0.5%를 곱한 금액을 납부세액에서 공제한다."
    },
    {
        question: "다음 중 부가가치세법상 의제매입세액공제제도에 관한 내용으로 가장 틀린 것은?",
        options: [
            "의제매입세액은 면세농산물 등을 공급받거나 수입한 날이 속하는 과세기간의 매출세액에서 공제한다.",
            "의제매입세액공제는 사업자등록을 한 부가가치세 과세사업자가 적용대상자이며, 미등록자는 허용되지 않는다.",
            "면세농산물 등의 매입가액에는 운임 등의 직접 부대비용 및 관세를 포함한다.",
            "면세농산물 등에 대하여 세금계산서 없이도 일정한 금액을 매입세액으로 의제하여 공제하는 것이기 때문에 의제매입세액공제라고 한다."
        ],
        correct: 2,
        explanation: "부가가치세 집행기준 42-84-5: 의제매입세액의 공제대상이 되는 원재료의 매입가액은 운임 등의 부대비용을 제외한 매입원가로 한다."
    },
    {
        question: "다음 중 소득세법상 근로소득과 관련된 내용으로 틀린 것은?",
        options: [
            "식사나 기타 음식물을 제공받지 않는 근로자가 받는 월 20만원 이하의 식사대는 비과세 근로소득이다.",
            "종업원이 지급받은 경조금 중 사회통념상 타당하다고 인정되는 범위 내의 금액은 근로소득으로 보지 않는다.",
            "고용관계에 의하여 지급받은 강연료는 근로소득이다.",
            "근로자의 가족에 대한 학자금은 비과세 근로소득이다."
        ],
        correct: 3,
        explanation: "근로자의 가족에 대한 학자금은 근로소득으로 과세한다."
    },
    {
        question: "다음 중 소득세법상 과세표준 확정신고를 반드시 하여야 하는 경우는?",
        options: [
            "퇴직소득만 있는 경우",
            "근로소득과 사업소득이 있는 경우",
            "근로소득과 퇴직소득이 있는 경우",
            "근로소득과 보통예금이자 150만원(14% 원천징수세율 적용 대상)이 있는 경우"
        ],
        correct: 1,
        explanation: "근로소득과 사업소득이 있는 경우 과세표준확정신고의 예외에 해당하지 않으므로 반드시 확정신고를 해야 한다."
    },
    {
        question: "다음 중 소득세법상 종합소득공제에 대한 설명으로 가장 옳지 않은 것은?",
        options: [
            "근로소득금액 5,000,000원이 있는 40세 배우자는 기본공제 대상자에 해당한다(단, 다른 소득은 없다).",
            "종합소득금액이 35,000,000원이고, 배우자가 없는 거주자로서 기본공제 대상자인 직계비속이 있는 자는 한부모공제가 가능하다.",
            "부녀자공제와 한부모공제가 중복되는 경우에는 한부모공제만 적용한다.",
            "기본공제 대상자가 아닌 자는 추가공제 대상자가 될 수 없다."
        ],
        correct: 0,
        explanation: "총급여액 5,000,000원 이하의 근로소득만 있는 자가 기본공제 대상자에 해당한다. 한부모공제는 소득금액 제한이 없다."
    }
];

// 113회 문제 데이터
const quiz113Data = [
    {
        question: "다음 중 재무상태표의 구성요소에 대한 설명으로 틀린 것은?",
        options: [
            "부채는 유동성에 따라 유동부채와 비유동부채로 구분한다.",
            "자산과 부채는 유동성이 큰 항목부터 배열하는 것을 원칙으로 한다.",
            "자산은 유동자산과 비유동자산으로 구분하며 유동자산은 당좌자산과 투자자산으로 구분한다.",
            "자본은 자본금, 자본잉여금, 자본조정, 기타포괄손익누계액 및 이익잉여금(결손금)으로 구분한다."
        ],
        correct: 2,
        explanation: "유동자산은 당좌자산과 재고자산으로 구분하고 투자자산은 비유동자산에 속한다."
    },
    {
        question: "다음의 자료를 이용하여 기말 자본잉여금을 구하시오. 단, 기초 자본잉여금은 10,000,000원이다.\n\n당기에 발생한 자본 항목의 증감 내역은 아래와 같다.\n• 주식발행초과금 증가 2,000,000원\n• 이익준비금 적립 3,000,000원\n• 자기주식처분이익 발생 300,000원\n• 자본금 증가 5,000,000원",
        options: [
            "12,000,000원",
            "12,300,000원",
            "15,000,000원",
            "17,000,000원"
        ],
        correct: 1,
        explanation: "12,300,000원 = 기초 자본잉여금 10,000,000원 + 주식발행초과금 2,000,000원 + 자기주식처분이익 300,000원"
    },
    {
        question: "다음 중 받을어음의 대손충당금을 과대 설정하였을 경우 재무제표에 미치는 영향으로 올바른 것은?",
        options: [
            "자산의 과소계상",
            "비용의 과소계상",
            "당기순이익 과대계상",
            "이익잉여금의 과대계상"
        ],
        correct: 0,
        explanation: "대손충당금 과대 설정은 동시에 대손상각비가 과대 계상된다."
    },
    {
        question: "다음 중 일반기업회계기준에 따른 유형자산에 대한 설명으로 옳지 않은 것은?",
        options: [
            "취득원가는 구입원가 또는 제작원가 및 경영진이 의도하는 방식으로 자산을 가동하는 데 필요한 장소와 상태에 이르게 하는 데 직접 관련되는 원가로 구성된다.",
            "취득세, 등록면허세 등 유형자산의 취득과 직접 관련된 제세공과금은 당기비용으로 처리한다.",
            "새로운 상품과 서비스를 소개하는 데 소요되는 원가(예：광고 및 판촉활동과 관련된 원가)는 유형자산의 원가를 구성하지 않는다.",
            "건물을 신축하기 위하여 사용 중인 기존 건물을 철거하는 경우 그 건물의 장부금액은 제거하여 처분손실로 반영하고, 철거비용은 전액 당기비용으로 처리한다."
        ],
        correct: 1,
        explanation: "취득세, 등록면허세 등 유형자산의 취득과 직접 관련된 제세공과금은 유형자산의 원가를 구성한다."
    },
    {
        question: "다음 중 충당부채에 대한 설명으로 틀린 것은?",
        options: [
            "과거사건에 의해 충당부채를 인식하기 위해서는 그 사건이 기업의 미래행위와 독립적이어야 한다.",
            "충당부채는 보고기간말마다 그 잔액을 검토하고, 보고기간말 현재 최선의 추정치를 반영하여 증감 조정한다.",
            "충당부채를 발생시킨 사건과 밀접하게 관련된 자산의 예상되는 처분차익은 충당부채 금액의 측정에 고려하지 아니한다.",
            "의무발생사건의 결과로 현재의무가 존재하면 자원의 유출 가능성이 낮더라도 충당부채로 인식해야 한다."
        ],
        correct: 3,
        explanation: "일반기업회계기준 문단 14.3: 충당부채는 과거사건이나 거래의 결과에 의한 현재의무로서, 지출의 시기 또는 금액이 불확실하지만 그 의무를 이행하기 위하여 자원이 유출될 가능성이 매우 높고 또한 당해 금액을 신뢰성 있게 추정할 수 있는 의무를 말한다."
    },
    {
        question: "㈜한국은 선입선출법에 의한 종합원가계산을 적용하고 있으며, 당기 생산 관련 자료는 아래와 같다. 품질검사는 완성도 30% 시점에서 이루어지며, 당기에 검사를 통과한 정상품의 3%를 정상공손으로 간주한다. 당기의 정상공손수량은 몇 개인가?\n\n<물량흐름>\n기초재공품: 500개 (완성도 70%)\n당기착수량: 2,000개\n당기완성량: 2,000개\n기말재공품: 300개 (완성도 50%)",
        options: [
            "51개",
            "54개",
            "60개",
            "75개"
        ],
        correct: 1,
        explanation: "당기에 검사를 통과한 정상품: 1,500개 + 300개 = 1,800개. 정상공손수량: 1,800개 × 3% = 54개"
    },
    {
        question: "다음 중 원가회계의 목적과 거리가 먼 것은?",
        options: [
            "내부 경영 의사결정에 필요한 원가 정보를 제공하기 위함이다.",
            "원가통제에 필요한 원가 정보를 제공하기 위함이다.",
            "손익계산서상 제품 원가에 대한 원가 정보를 제공하기 위함이다.",
            "이익잉여금처분계산서상 이익잉여금 처분 정보를 제공하기 위함이다."
        ],
        correct: 3,
        explanation: "이익잉여금처분은 주주에게 지급하는 배당 등을 의미하며 주주인 외부 이해관계자에게 제공하는 것은 재무회계의 목적에 해당한다."
    },
    {
        question: "다음은 정상원가계산을 채택하고 있는 ㈜서울의 2024년 원가 관련 자료이다. ㈜서울은 직접노동시간에 비례하여 제조간접원가를 배부한다. 제조간접원가 배부액을 구하시오.\n\n• 제조간접원가 예산: 39,690,000원\n• 예산 직접노동시간: 90,000시간\n• 실제 제조간접원가: 44,100,000원\n• 실제 직접노동시간: 70,000시간",
        options: [
            "30,870,000원",
            "34,300,000원",
            "47,800,000원",
            "51,030,000원"
        ],
        correct: 0,
        explanation: "30,870,000원 = 실제 직접노동시간 70,000시간 × 제조간접원가 예정배부율 441원. 제조간접원가 예정배부율: 제조간접원가 예산 39,690,000원 ÷ 예산 직접노동시간 90,000시간 = 441원/직접노동시간"
    },
    {
        question: "다음 중 제조원가의 분류로 잘못 구성된 것을 고르시오.",
        options: [
            "추적가능성에 따른 분류: 직접재료원가, 간접재료원가, 직접노무원가, 간접노무원가",
            "제조원가의 요소에 따른 분류: 직접재료원가, 직접노무원가, 제조간접원가",
            "원가행태에 따른 분류: 재료원가, 노무원가, 제조간접원가",
            "발생형태에 따른 분류: 재료원가, 노무원가, 제조경비"
        ],
        correct: 2,
        explanation: "제조원가를 원가행태에 따른 분류하면 변동제조원가, 고정제조원가로 분류한다."
    },
    {
        question: "다음 중 보조부문원가의 배분 방법에 대한 설명으로 옳은 것은?",
        options: [
            "직접배분법은 보조부문 상호간의 용역수수관계를 전혀 인식하지 않아 항상 가장 부정확하다.",
            "상호배분법은 보조부문 상호간의 용역수수관계를 가장 정확하게 배분하므로 가장 많이 이용된다.",
            "단계배분법은 보조부문 상호간의 용역수수관계를 일부 인식하며 배분 순서에 따라 결과가 달라진다.",
            "단계배분법은 우선순위가 낮은 부문의 원가를 우선순위가 높은 부문과 제조부문에 먼저 배분한다."
        ],
        correct: 2,
        explanation: "단계배분법은 우선순위가 높은 부문의 보조부문원가를 우선순위가 낮은 부문과 제조부문에 먼저 배분하는 방법으로 상호간의 용역수수관계를 일부 인식하지만 배분 순서가 부적절한 경우 직접배분법보다도 정확성이 떨어질 수 있다. 상호배분법은 보조부문 상호간의 용역수수관계를 가장 정확하게 배분하지만 보조부문의 수가 여러 개일 경우 시간과 비용이 많이 소요되고 계산하기가 어려워 실무상 거의 사용되지 않는다."
    },
    {
        question: "다음 중 부가가치세법상 아래의 수정세금계산서 발급 방법에 대한 수정세금계산서 발급 사유로 옳은 것은?\n\n(수정세금계산서 발급 방법)\n사유 발생일을 작성일로 적고 비고란에 처음 세금계산서 작성일을 덧붙여 적은 후 붉은색 글씨로 쓰거나 음의 표시를 하여 발급",
        options: [
            "착오로 전자세금계산서를 이중으로 발급한 경우",
            "계약의 해제로 재화 또는 용역이 공급되지 아니한 경우",
            "필요적 기재사항 등이 착오 외의 사유로 잘못 적힌 경우",
            "면세 등 세금계산서 발급 대상이 아닌 거래 등에 대하여 세금계산서를 발급한 경우"
        ],
        correct: 1,
        explanation: "부가가치세법 시행령 제70조 제1항 제2호"
    },
    {
        question: "다음 중 부가가치세법상 공제하지 아니하는 매입세액이 아닌 것은?",
        options: [
            "토지에 관련된 매입세액",
            "사업과 직접 관련이 없는 지출에 대한 매입세액",
            "기업업무추진비 및 이와 유사한 비용 지출에 대한 매입세액",
            "세금계산서 임의적 기재사항의 일부가 적히지 아니한 지출에 대한 매입세액"
        ],
        correct: 3,
        explanation: "세금계산서 임의적 기재사항의 일부가 적히지 아니한 지출에 대한 매입세액은 공제가 가능하다. 필요적 기재사항의 일부가 적히지 아니한 지출에 대한 매입세액에 대해서는 공제 불가하다."
    },
    {
        question: "다음 중 부가가치세법상 환급에 대한 설명으로 가장 옳지 않은 것은?",
        options: [
            "각 과세기간별로 그 과세기간에 대한 환급세액을 확정신고한 사업자에게 그 확정신고기한이 지난 후 25일 이내에 환급하여야 한다.",
            "재화 및 용역의 공급에 영세율을 적용받는 경우 조기환급 신고할 수 있다.",
            "조기환급 신고의 경우 조기환급 신고기한이 지난 후 15일 이내에 환급할 수 있다.",
            "사업 설비를 신설･취득･확장 또는 증축하는 경우 조기환급 신고할 수 있다."
        ],
        correct: 0,
        explanation: "부가가치세법 제59조: 납세지 관할 세무서장은 각 과세기간별로 그 과세기간에 대한 환급세액을 확정신고한 사업자에게 그 확정신고기한이 지난 후 30일 이내(제2항 각 호의 어느 하나에 해당하는 경우에는 15일 이내)에 대통령령으로 정하는 바에 따라 환급하여야 한다."
    },
    {
        question: "다음 중 소득세법상 종합소득에 대한 설명으로 틀린 것은?",
        options: [
            "이자소득은 총수입금액과 소득금액이 동일하다.",
            "퇴직소득과 양도소득은 종합소득에 해당하지 않는다.",
            "사업소득, 근로소득, 연금소득, 기타소득에는 비과세 소득이 존재한다.",
            "금융소득(이자 및 배당)은 납세자의 선택에 따라 금융소득종합과세를 적용할 수 있다."
        ],
        correct: 3,
        explanation: "금융소득은 납세자의 선택에 따라 종합소득합산과세를 적용할 수 없으며 금융소득이 연 2천만원을 초과하는 경우 금융소득종합과세를 적용한다."
    },
    {
        question: "다음 중 소득세법상 결손금과 이월결손금에 대한 설명으로 가장 옳지 않은 것은?",
        options: [
            "비주거용 부동산 임대업에서 발생한 이월결손금은 타 소득에서 공제할 수 없다.",
            "추계 신고 시에는 원칙적으로 이월결손금을 공제할 수 없다.",
            "해당 과세기간에 일반사업소득에서 결손금이 발생하고 이월결손금도 있는 경우에는 이월결손금을 먼저 다른 소득금액에서 공제한다.",
            "결손금의 소급공제는 중소기업에 한하여 적용 가능하다."
        ],
        correct: 2,
        explanation: "당해 과세기간에 발생한 결손금을 먼저 다른 소득금액에서 공제한다."
    }
];

// 회차별 문제 데이터 (115-122회는 데이터 양이 많아 현재는 112, 113회만 구현)
// TODO: 115-122회 데이터 추가 필요
const roundData = {
    112: quizData,
    113: quiz113Data
    // 115: quiz115Data,
    // 116: quiz116Data,
    // ... 122회까지 추가 예정
};

let currentQuestion = 0;
let score = 0;
let selectedAnswer = null;
let isAnswered = false;
let answersRecord = []; // 각 문제의 답안 기록 {answered: true/false, correct: true/false, selectedAnswer: index}
let currentRound = 112; // 현재 선택된 회차

// 회차 선택 함수
function selectRound(round) {
    currentRound = round;
    
    // 문제풀이 섹션으로 이동
    document.querySelectorAll('.content-section').forEach(section => {
        section.classList.remove('active');
    });
    document.getElementById('quiz-section').classList.add('active');
    
    // 메뉴 활성화 업데이트
    document.querySelectorAll('.menu-item').forEach(item => {
        item.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // 해당 회차 문제가 있는지 확인
    if (roundData[round]) {
        startQuiz(round);
    } else {
        // 문제가 아직 없는 경우
        const quizContainer = document.getElementById('quiz-container');
        quizContainer.innerHTML = `
            <div class="info-box">
                <h3>${round}회 문제</h3>
                <p class="coming-soon">준비 중입니다...</p>
                <p>문제를 추가하려면 관리자에게 문의해주세요.</p>
            </div>
        `;
        document.getElementById('question-nav').style.display = 'none';
        document.querySelector('.restart-quiz-button').style.display = 'none';
        document.getElementById('quiz-title').textContent = `${round}회 문제 풀이`;
    }
}

// 섹션 전환 함수
function showSection(sectionName) {
    // 모든 섹션 숨기기
    document.querySelectorAll('.content-section').forEach(section => {
        section.classList.remove('active');
    });
    
    // 모든 메뉴 아이템 비활성화
    document.querySelectorAll('.menu-item').forEach(item => {
        item.classList.remove('active');
    });
    
    // 선택한 섹션 표시
    const section = document.getElementById(`${sectionName}-section`);
    if (section) {
        section.classList.add('active');
    }
    
    // 선택한 메뉴 아이템 활성화
    event.target.classList.add('active');
}

function startQuiz(round = currentRound) {
    currentRound = round;
    const questions = roundData[round] || quizData;
    
    currentQuestion = 0;
    score = 0;
    selectedAnswer = null;
    isAnswered = false;
    
    // 답안 기록 초기화
    answersRecord = questions.map(() => ({
        answered: false,
        correct: false,
        selectedAnswer: null
    }));
    
    const quizContainer = document.getElementById('quiz-container');
    quizContainer.innerHTML = '';
    
    // 제목 업데이트
    document.getElementById('quiz-title').textContent = `${round}회 문제 풀이`;
    
    // 문제 네비게이션 표시
    document.getElementById('question-nav').style.display = 'block';
    document.querySelector('.restart-quiz-button').style.display = 'inline-block';
    
    createQuestionNavigation();
    displayQuestion();
}

function restartQuiz() {
    startQuiz(currentRound);
}

function createQuestionNavigation() {
    const questions = roundData[currentRound] || quizData;
    const navContainer = document.getElementById('question-nav');
    
    // 총 점수 계산 (각 문제당 2점)
    const totalScore = answersRecord.filter(record => record.answered && record.correct).length * 2;
    const maxScore = questions.length * 2;
    
    let html = '<div class="nav-header">';
    html += '<h3>문제 번호</h3>';
    html += `<div class="score-display">점수: <strong>${totalScore}</strong> / ${maxScore}점</div>`;
    html += '</div>';
    html += '<div class="question-numbers">';
    
    for (let i = 0; i < questions.length; i++) {
        let className = 'question-number-btn';
        if (i === currentQuestion) {
            className += ' current';
        }
        if (answersRecord[i].answered) {
            className += answersRecord[i].correct ? ' correct' : ' wrong';
        }
        
        html += `<button class="${className}" onclick="goToQuestion(${i})">${i + 1}</button>`;
    }
    
    html += `</div>`;
    navContainer.innerHTML = html;
}

function goToQuestion(index) {
    if (isAnswered) {
        // 현재 문제의 답안 저장
        saveCurrentAnswer();
    }
    
    currentQuestion = index;
    selectedAnswer = answersRecord[index].selectedAnswer;
    isAnswered = answersRecord[index].answered;
    
    displayQuestion();
    createQuestionNavigation();
}

function saveCurrentAnswer() {
    answersRecord[currentQuestion] = {
        answered: isAnswered,
        correct: isAnswered && (selectedAnswer === quizData[currentQuestion].correct),
        selectedAnswer: selectedAnswer
    };
}

function displayQuestion() {
    const questions = roundData[currentRound] || quizData;
    const quizContainer = document.getElementById('quiz-container');
    const question = questions[currentQuestion];
    
    // 이전에 저장된 답안이 있으면 복원
    const savedAnswer = answersRecord[currentQuestion];
    selectedAnswer = savedAnswer.selectedAnswer;
    isAnswered = savedAnswer.answered;
    
    let html = `
        <div class="question-card">
            <div class="question-number">문제 ${currentQuestion + 1} / ${questions.length}</div>
            <div class="question-text">${question.question}</div>
            <div class="options">
                ${question.options.map((option, index) => {
                    let optionClass = 'option';
                    if (isAnswered) {
                        if (index === question.correct) {
                            optionClass += ' correct';
                        }
                        if (index === selectedAnswer && index !== question.correct) {
                            optionClass += ' wrong';
                        }
                    } else if (index === selectedAnswer) {
                        optionClass += ' selected';
                    }
                    return `
                        <div class="${optionClass}" onclick="selectAnswer(${index})" id="option-${index}">
                            ${index + 1}. ${option}
                        </div>
                    `;
                }).join('')}
            </div>
            <button class="submit-button" onclick="checkAnswer()" id="submit-btn" ${isAnswered || selectedAnswer === null ? 'disabled' : ''}>
                ${isAnswered ? '답안 확인됨' : '정답 확인'}
            </button>
            <div id="explanation-area">${isAnswered ? generateExplanationHTML(question) : ''}</div>
        </div>
    `;
    
    quizContainer.innerHTML = html;
    
    // 네비게이션 업데이트
    createQuestionNavigation();
}

function generateExplanationHTML(question) {
    const isCorrect = selectedAnswer === question.correct;
    return `
        <div class="explanation">
            <h4>${isCorrect ? '✅ 정답입니다!' : '❌ 오답입니다.'}</h4>
            <p>${question.explanation}</p>
        </div>
    `;
}

function selectAnswer(index) {
    if (isAnswered) return;
    
    // 이전 선택 해제
    document.querySelectorAll('.option').forEach(opt => {
        opt.classList.remove('selected');
    });
    
    // 새로운 선택
    document.getElementById(`option-${index}`).classList.add('selected');
    selectedAnswer = index;
    
    // 정답 확인 버튼 활성화
    document.getElementById('submit-btn').disabled = false;
}

function checkAnswer() {
    if (selectedAnswer === null || isAnswered) return;
    
    const questions = roundData[currentRound] || quizData;
    isAnswered = true;
    const question = questions[currentQuestion];
    const isCorrect = selectedAnswer === question.correct;
    
    if (isCorrect) {
        score++;
    }
    
    // 답안 기록 저장
    answersRecord[currentQuestion] = {
        answered: true,
        correct: isCorrect,
        selectedAnswer: selectedAnswer
    };
    
    // 정답 표시
    document.getElementById(`option-${question.correct}`).classList.add('correct');
    
    // 오답인 경우 선택한 답 표시
    if (!isCorrect) {
        document.getElementById(`option-${selectedAnswer}`).classList.add('wrong');
    }
    
    // 해설 표시
    const explanationArea = document.getElementById('explanation-area');
    explanationArea.innerHTML = generateExplanationHTML(question);
    
    // 버튼 변경
    const submitBtn = document.getElementById('submit-btn');
    if (currentQuestion < questions.length - 1) {
        submitBtn.textContent = '다음 문제';
        submitBtn.onclick = nextQuestion;
        submitBtn.disabled = false;
    } else {
        submitBtn.textContent = '결과 보기';
        submitBtn.onclick = showResults;
        submitBtn.disabled = false;
    }
    
    // 네비게이션 업데이트
    createQuestionNavigation();
}

function nextQuestion() {
    currentQuestion++;
    selectedAnswer = answersRecord[currentQuestion].selectedAnswer;
    isAnswered = answersRecord[currentQuestion].answered;
    displayQuestion();
}

function showResults() {
    const questions = roundData[currentRound] || quizData;
    // 최종 점수 계산 (각 문제당 2점)
    const correctCount = answersRecord.filter(record => record.correct).length;
    const finalScore = correctCount * 2;
    const maxScore = questions.length * 2;
    
    const quizContainer = document.getElementById('quiz-container');
    const percentage = Math.round((finalScore / maxScore) * 100);
    
    let resultMessage = '';
    if (percentage >= 80) {
        resultMessage = '훌륭합니다! 합격권입니다! 🎉';
    } else if (percentage >= 60) {
        resultMessage = '좋습니다! 조금만 더 노력하세요! 💪';
    } else {
        resultMessage = '더 공부가 필요합니다. 화이팅! 📚';
    }
    
    quizContainer.innerHTML = `
        <div class="result-summary">
            <h3>${currentRound}회 문제 풀이 완료!</h3>
            <div class="score">${finalScore} / ${maxScore}점</div>
            <p style="font-size: 1.3rem; margin: 1rem 0;">${percentage}% (${correctCount}문제 정답)</p>
            <p style="font-size: 1.1rem; color: #666;">${resultMessage}</p>
            <div class="result-buttons">
                <button class="restart-button" onclick="restartQuiz()">다시 풀기</button>
                <button class="review-button" onclick="reviewWrongAnswers()">오답만 보기</button>
            </div>
        </div>
    `;
}

function reviewWrongAnswers() {
    const wrongQuestions = answersRecord
        .map((record, index) => ({...record, questionIndex: index}))
        .filter(record => record.answered && !record.correct);
    
    if (wrongQuestions.length === 0) {
        alert('모든 문제를 맞히셨습니다! 🎉');
        return;
    }
    
    // 첫 번째 틀린 문제로 이동
    goToQuestion(wrongQuestions[0].questionIndex);
}

// 페이지 로드 시 스크롤 애니메이션
document.addEventListener('DOMContentLoaded', function() {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.style.opacity = '1';
                entry.target.style.transform = 'translateY(0)';
            }
        });
    });
    
    document.querySelectorAll('.feature-card').forEach(card => {
        card.style.opacity = '0';
        card.style.transform = 'translateY(20px)';
        card.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
        observer.observe(card);
    });
});
